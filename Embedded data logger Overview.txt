Embedded Data Logger

There are three folders, a folder for the pseudo code, a folder for the python code, and a folder for the task 2.3.2 flowchart
The code files can also be found in this directory (/home/pi/.config/spyder-py3/Embedded data logger) in the device number 18

This porject was divided into 8 tasks.

each task has it is own code in a single notepad file. in addition, each file has an associated pseudo code notepad with the same name as the task but with 
the word documentation added to it.

this file contains the functionalities description of each task.

Task 2.1.1 Acquisition of range measurment:
in this task a function called ultrasonic_function was created to calculate the measured pulse time of the echo sensor, when calling this function, 
the echo and trigger pins are passed to the function and the function returns the measured pulse time to be printed.

Task 2.1.2 Visualizing the distance measure on the 7 segment display:
In this task there are two files, a file for the normal system in which the ultrasonic function is called every second and then it passes the value
of the measured echo time to another function called seg_display and in this function, the echo time is scaled to be between 0 and 100% and this 
percentage is then presented on the 7 segement display.
Since the remote system was used, another code was created, in which the user is asked to input the percentage himself, and this value is then 
shown on the 7 segement display.

Task 2.1.3 Visualizing the distance measure on the MLD
the functions from the first two tasks were used and a list called bar_height was created and the readings from the ultrasonic sensors were appended to 
this list, then the latest recorder sample gathered from the ultrasonic sensor is always on the rightmost column of the MLD and a moving graph is 
generated by deleting the oldest gathered sample when the number of gathered samples exceeds 8.
 
Task 2.1.4 Test setup for basic functionality
since the remote was used, testing the system was done by assigning a random value to the echo_time and then multiplying it by 200. after that this value 
was divided by 2 to be a precentage between 0 and 100% and it was scaled again to be shown on the MLD. The refresh rate between every reading is 1 second.

Task 2.2 Update rate
Task 2.1.4 was repeated here, but there is 1 difference which is that the refresh rate is set by the user. the system will ask the user to input a value
between 1 and 9. if the user inputs another number outside of this range, the system will not assign this value to the sleep function and it will ask the 
user again to input a value between 1 and 9.

Task 2.3.1 Implementation of a fifo data buffer
In order to implement a fifo buffer that can store up to 100 values, a built-in function called dequeue was used. This function takes two inputs, the 
size of the list (queue) and the values of these 100 values. The last read value by the sensor (or the generated random value since the remote system 
was used) is enqueued in the list until the list reachs 100, then the value 101 will be dequeued to make space for the last read value.

Task 2.3.2 Visualization of archived elements
It is quite complicated to understand what was done in this task from the pseudo code, so a flow chart was drawn to better understand this task. in 
this task, the entire program was set to a function called my program and there was another function to abort the system when it is called. In order to 
enter the pause mode, try and except were used and the exception thrown was the KeyboardInterrupt exception (ctrl + c), when the user presses ctrl + c 
the system is paused and during that time he can navigate through the archived data by pressing 1 followed by enter and he can exit the system completely
by pressing 0 followed by enter and he can restart the system by pressing ctrl+c. 

Task 2.4 Calibration
In this task, the calibration was calculated at the before showing any readings. 

Notes:
1- In tasks 2.1.2, 2.1.3, 2.1.4, 2.2, and 2.3.1, the data shown on the seven segement display is the precentage of the reading, meaning that, the heighst 
reading is of value 100 and the lowest reading is of value of 0. However, in task 2.3.4 and 2.4, when the user navigates through the archived values, the
value shown on the seven segement is a random value multiplies by 200.

2- In tasks 2.2, 2.3.2, and 2.4, I tried to use the keyboard library but I could not do so due to a limitation in the rasperry pi, I also tried using 
threading in task 2.4 but the system beahved in a non inteded way.
 
3- In task 2.4, I do not know if the buzzer works or not during data collection because I am using the remote system

4- In task 2.4, it was required that the system does the calibration based on whether or not the user presses a dedicated button, but since I was not
able to use the keyboard module and I have already used the one possible keyboard interrupt in the previous task, I was not able to dedicate a button
press for this speciefic task


 